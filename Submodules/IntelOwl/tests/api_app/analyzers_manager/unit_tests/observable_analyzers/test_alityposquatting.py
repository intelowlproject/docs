from unittest.mock import patch

from api_app.analyzers_manager.observable_analyzers.ailtyposquatting import (
    AilTypoSquatting,
)
from tests.api_app.analyzers_manager.unit_tests.observable_analyzers.base_test_class import (
    BaseAnalyzerTest,
)


class AilTypoSquattingTestCase(BaseAnalyzerTest):
    analyzer_class = AilTypoSquatting

    @staticmethod
    def get_mocked_response():
        # Mock typosquatting results - these would be similar domains generated by various algorithms
        mock_typo_results = [
            "exmaple.com",  # Character swap
            "exampl.com",  # Character omission
            "examplee.com",  # Character repetition
            "exampie.com",  # Character replacement
            "example.org",  # TLD substitution
            "example.net",  # TLD substitution
            "exampel.com",  # Character transposition
            "wexample.com",  # Character insertion
            "3xample.com",  # Homograph attack
            "examp1e.com",  # Character substitution with numbers
        ]

        # Mock DNS resolving results - subset of domains that actually resolve
        mock_dns_results = [
            {"domain": "exmaple.com", "A": ["192.168.1.100"], "resolved": True},
            {"domain": "example.org", "A": ["192.168.1.101"], "resolved": True},
            {"domain": "exampl.com", "resolved": False},
        ]

        return [
            patch("ail_typo_squatting.typo.runAll", return_value=mock_typo_results),
            patch(
                "ail_typo_squatting.dns_local.resolving.dnsResolving",
                return_value=mock_dns_results,
            ),
        ]

    @classmethod
    def get_extra_config(cls) -> dict:
        return {
            "dns_resolving": True,
        }
